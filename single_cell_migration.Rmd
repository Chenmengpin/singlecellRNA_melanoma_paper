```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("/media/data/lcb/lminn/Migration") 
```

General:
- X and Y are the coordinates recorded by the tracking
- Real.X and Y are the coordinated corrected for the angle of the channel
- Relative.Y is the relative distance on the y-axis that a cell has travelled compared to the first frame

# MM099

## Loading data

```{r}
data <- read.table("2018713_MM099_trial4_phase_tracking_all.txt",sep = "\t",header=T)
data <- data[,c(1,2,8)]

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)




# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:76)){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM099_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

  
```


## Putting treshold on when a cell starts moving


```{r}
data <- read.table("/media/data/lcb/lminn/Migration/2018713_MM099_trial4_phase_tracking-XandY.txt",sep = "\t",header=T)

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:76)){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,6] - subset[1,6])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  ylim(0,1550)

MM099 <- new

# select only the point that pass 120 um
new2 <- new[which(new$Relative.Y.um >120),]

ggplot(new2) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))


write.table(new2,"/media/data/lcb/lminn/Migration/2018713_MM099_trial4_phase_tracking-XandY_RelYum120.txt",quote=F, sep = "\t",row.names = F)

# select only the point that pass 50 um
new2 <- new[which(new$Relative.Y.um >50),]

ggplot(new2) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))


write.table(new2,"/media/data/lcb/lminn/Migration/2018713_MM099_trial4_phase_tracking-XandY_RelYum50.txt",quote=F, sep = "\t",row.names = F)


```


```{r}
# Plotting velocity

data <- read.table("/media/data/lcb/lminn/Migration/2018713_MM099_trial4_phase_tracking_all.txt",sep = "\t",header=T)

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,9] - subset[1,9])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

x <- (new$Relative.Y.um)
x2 <- x
x2[2:(length(x))] <-x[0:(length(x)-1)]
x2[1] <- 0


rel.velocity <- x - x2
new$rel.velocity <- rel.velocity

ggplot(new) +
  geom_point(aes(x=TimeHour, y=rel.velocity,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=rel.velocity,col=Cell,group=Cell)) +
  ylim(4,5)

uniq<-unique(new$rel.velocity)  


ggplot(new,aes(TimeHour,(rel.velocity))) +
    geom_boxplot() +
    ylim(-25,25)
  
  
a 
p <- aggregate(data.frame(count = new$rel.velocity), list(value = new$rel.velocity), length)

plot(p$value,p$count)

```


# M0057

## Loading data

```{r}
data <- read.table("20180801_MM057_R1_tracking_all.txt",sep = "\t",header=T)
data <- data[,c(1,2,6)]

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)


# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM057_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

MM057 <- new

  
```


## Putting treshold on when a cell starts moving


```{r}
data <- read.table("/media/data/lcb/lminn/Migration/20180801_MM057_R1_tracking_all.txt",sep = "\t",header=T)

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,6] - subset[1,6])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  ylim(0,1550)

# MM057 <- new

# select only the point that pass 120 um

new2 <- new[which(new$Relative.Y.um >120),]

ggplot(new2) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))


write.table(new2,"/media/data/lcb/lminn/Migration/20180801_MM057_R1_tracking_all_RelYum120.txt",quote=F, sep = "\t",row.names = F)

# select only the point that pass 50 um

new2 <- new[which(new$Relative.Y.um >50),]

ggplot(new2) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))


write.table(new2,"/media/data/lcb/lminn/Migration/20180801_MM057_R1_tracking_all_RelYum50.txt",quote=F, sep = "\t",row.names = F)


```


# MM087

## Loading data

```{r}
data <- read.table("20180808_MM087_R3_phase_tracking_all.txt",sep = "\t",header=T)
data <- data[,c(1,2,9)]

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM087_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

  
```


## Putting treshold on when a cell starts moving


```{r}
data <- read.table("/media/data/lcb/lminn/Migration/20180808_MM087_R3_phase_tracking_all.txt",sep = "\t",header=T)

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,9] - subset[1,9])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  ylim(0,1550)

MM087 <- new

# select only the point that pass 120 um

new2 <- new[which(new$Relative.Y.um >120),]

ggplot(new2) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))


write.table(new2,"/media/data/lcb/lminn/Migration/20180808_MM087_R3_phase_tracking_all_RelYum120.txt",quote=F, sep = "\t",row.names = F)


# select only the point that pass 50 um

new2 <- new[which(new$Relative.Y.um >50),]

ggplot(new2) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))


write.table(new2,"/media/data/lcb/lminn/Migration/20180801_MM087_R1_tracking_all_RelYum50.txt",quote=F, sep = "\t",row.names = F)


```

```{r}
# Plotting velocity

data <- read.table("/media/data/lcb/lminn/Migration/20180808_MM087_R3_phase_tracking_all.txt",sep = "\t",header=T)

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,9] - subset[1,9])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

x <- (new$Relative.Y.um)
x2 <- x
x2[2:(length(x))] <-x[0:(length(x)-1)]
x2[1] <- 0


rel.velocity <- x - x2
new$rel.velocity <- rel.velocity

ggplot(new) +
  geom_point(aes(x=TimeHour, y=rel.velocity,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=rel.velocity,col=Cell,group=Cell)) +
  ylim(-50,50)

uniq<-unique(new$rel.velocity)  
boxplot(uniq, ylim=(-50,50))


ggplot(new,aes(TimeHour,(rel.velocity))) +
    geom_boxplot() +
    ylim(-25,25)
  
  
a 
p <- aggregate(data.frame(count = new$rel.velocity), list(value = new$rel.velocity), length)

plot(p$value,p$count)

```


# MM031

## Loading data

```{r}
data <- read.table("20181022_MM031_R1_tracking_all.txt",sep = "\t",header=T)
data <- data[,c(1,2,4)]
colnames(data) <- c("Cell","Frame","Real.Y")

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM031_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

MM031 <- new
  
```


# MM011

## Loading data

```{r}
data <- read.table("20180926_MM011_R1_tracking-all_woCell1.txt",sep = "\t",header=T)
data <- data[,c(1,2,4)]
colnames(data) <- c("Cell","Frame","Real.Y")

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  print(paste("Cell",i))
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM011_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

MM011<- new  
```

# MM029

## Loading data

```{r}
data <- read.table("20181206_MM029_R2_tracking_all.txt",sep = "\t",header=T)
data <- data[,c(1,2,4)]
colnames(data) <- c("Cell","Frame","Real.Y")

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM029_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

MM029<- new  
```

# MM047

## Loading data

```{r}
data <- read.table("20181205_MM047_R1_tracking_all.txt",sep = "\t",header=T)
data <- data[,c(1,2,4)]
colnames(data) <- c("Cell","Frame","Real.Y")

# put actual time and distance in um
data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM047_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

MM047<- new  
```





# MM074

## Loading data

```{r}
data <- read.table("20181024_MM074_R2_tracking_all.txt",sep = "\t",header=T)
data <- data[,c(1,2,4)]
colnames(data) <- c("Cell","Frame","Real.Y")

# correct a wrong click
data[6121,3] <- 1752

# put actual time and distance in um
# 100 um is 89.7 pixels -> x um = Y * 100 / 89.7

data$TimeMin <- data$Frame*4
data$TimeHour <- data$Frame*4/60
data$Real.Y.um <- data$Real.Y*100/89.7
  

ggplot(data) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data$Cell))){
  subset = data[which(data$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM074_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

MM074<- new  
```



# MM001

## Loading data

```{r}
data <- read.table("20181212_MM001_tracking_allFormat.txt",sep = "\t",header=T)
data <- data[,c(1,2,4)]
colnames(data) <- c("Cell","Frame","Real.Y")

# add 2 extra rows so that we have 360 in total (add 1 in front, 1 at the end)
  # Have to do it for each cell
  # Fix the fram number
data2 <- data.frame()
for (i in c(1:max(data$Cell))){
  subset = data[which(data$Cell == i),]
  first <- subset[1,]
  last <- subset[nrow(subset),]
  x <- rbind(first, subset)
  y <- rbind(x, last)
  y$Frame <- c(1:360)
  data2 <- rbind(data2,y)
}


# put actual time and distance in um
# 100 um is 89.7 pixels -> x um = Y * 100 / 89.7

data2$TimeMin <- data2$Frame*4
data2$TimeHour <- data2$Frame*4/60
data2$Real.Y.um <- data2$Real.Y*100/89.7
  

ggplot(data2) +
  geom_point(aes(x=Frame, y=Real.Y,col=Cell),size=0.5)

# Calculate relative distance to the first coordinate per cell
new <- data.frame()
for (i in c(1:max(data2$Cell))){
  subset = data2[which(data2$Cell == i),]
  subset$Relative.Y.frame <- abs(subset[,3] - subset[1,3])
  new <- rbind(new,subset)
}

new$Relative.Y.um <- new$Relative.Y*100/89.7

ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.4) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell))

pdf("/media/data/lcb/lminn/Migration/MM001_Distance.pdf")
ggplot(new) +
  geom_point(aes(x=TimeHour, y=Relative.Y.um,col=Cell),size=0.2) +
  geom_line(aes(x=TimeHour, y=Relative.Y.um,col=Cell,group=Cell)) +
  labs(x = "Time (hour)",y = "Relative distance (um)") +
  ylim(0,1550)
dev.off()

MM001<- new  
```


```{r}
save(MM057, file="/media/data/lcb/lminn/Migration/MM057.Rdata")
save(MM087, file="/media/data/lcb/lminn/Migration/MM087.Rdata")
save(MM099, file="/media/data/lcb/lminn/Migration/MM099.Rdata")
save(MM011, file="/media/data/lcb/lminn/Migration/MM011.Rdata")
save(MM031, file="/media/data/lcb/lminn/Migration/MM031.Rdata")
save(MM029, file="/media/data/lcb/lminn/Migration/MM029.Rdata")
save(MM047, file="/media/data/lcb/lminn/Migration/MM047.Rdata")
save(MM074, file="/media/data/lcb/lminn/Migration/MM074.Rdata")
save(MM001, file="/media/data/lcb/lminn/Migration/MM001.Rdata")
```


## WITH MM074 and order: MM001, 011, 031, 074, 087, 057, 029, 047, 099 ## 

########################################################
#### Putting treshold on when a cell starts moving #####
########################################################

```{r}
load("/media/data/lcb/lminn/Migration/MM057.Rdata")
load("/media/data/lcb/lminn/Migration/MM087.Rdata")
load("/media/data/lcb/lminn/Migration/MM099.Rdata")
load("/media/data/lcb/lminn/Migration/MM011.Rdata")
load("/media/data/lcb/lminn/Migration/MM031.Rdata")
load("/media/data/lcb/lminn/Migration/MM029.Rdata")
load("/media/data/lcb/lminn/Migration/MM047.Rdata")
load("/media/data/lcb/lminn/Migration/MM001.Rdata")
load("/media/data/lcb/lminn/Migration/MM074.Rdata")

MM011$Line <- c(rep("MM011",nrow(MM011)))
MM029$Line <- c(rep("MM029",nrow(MM029)))
MM031$Line <- c(rep("MM031",nrow(MM031)))
MM047$Line <- c(rep("MM047",nrow(MM047)))
MM057$Line <- c(rep("MM057",nrow(MM057)))
MM087$Line <- c(rep("MM087",nrow(MM087)))
MM099$Line <- c(rep("MM099",nrow(MM099)))
MM001$Line <- c(rep("MM001",nrow(MM001)))
MM074$Line <- c(rep("MM074",nrow(MM074)))

# Only keep the data point for which the cell has already travelled 50 um relative to its start position
MM011_moving <- MM011[which(MM011$Relative.Y.um >50),]
MM029_moving <- MM029[which(MM029$Relative.Y.um >50),]
MM031_moving <- MM031[which(MM031$Relative.Y.um >50),]
MM047_moving <- MM047[which(MM047$Relative.Y.um >50),]
MM057_moving <- MM057[which(MM057$Relative.Y.um >50),]
MM087_moving <- MM087[which(MM087$Relative.Y.um >50),]
MM099_moving <- MM099[which(MM099$Relative.Y.um >50),]
MM001_moving <- MM001[which(MM001$Relative.Y.um >50),]
MM074_moving <- MM074[which(MM074$Relative.Y.um >50),]

data <- rbind(
  MM001_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM011_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM031_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM074_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM087_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM057_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM029_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM047_moving[,c("Cell","Frame","Relative.Y.um","Line")],
  MM099_moving[,c("Cell","Frame","Relative.Y.um","Line")])

```


# MSD on only the moving cells

```{r}
# Calculate the square displacement (kwadraat of the delta displacement at each time interval; for all the cells)
  # Here we take time interval dt = 1 ; so every row contains the squared distance travelled between t+1 and t
  # Iterate over the line, the cells within the line and then all t+1 - t displacements 
  # At the iteration with "j" : So what you do is that you fill at the firt iteration every where the number of y2-y1 and then with each iteration you overwrite the jth line, this makes that the 360th line is not empty but contains the firts values (which is almost always 0)
  # take care that in the iteration over the cells (i.e. i), you iterate over all AVAILABLE cell bnumbers instead of going from 1:max(cellNumber)
  # Similar, do not iterate over the nFrames as they are now cut, iterate over the nRows remaining
sqDispl <- data.frame()
for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
  subset_cellLine = data[which(data$Line == h),]
   for (i in c(unique(subset_cellLine$Cell))){
    subset = subset_cellLine[which(subset_cellLine$Cell == i),]
    for (j  in c(1:(nrow(subset)-1))){
      subset$deltaCoord[j] <- subset[j+1,"Relative.Y.um"] - subset[j,"Relative.Y.um"]   
      subset$sqDispl[j] <- subset$deltaCoord[j]*subset$deltaCoord[j]
     }
     sqDispl <- rbind(sqDispl,subset)
  }
}


# Calculate the average, std and n (number of dt's, is number of frames in dt =1) of the MSD for all cells (so this is the average MSD over all time points per cell per line)
# The cells that are not moving are NA rows here (so we iterate over all cell numbers, also the ones that were previously removed because dthey fo not move more than 50um) -> remove those

msd <- data.frame()
for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
  sqDispl_cellLine = sqDispl[which(sqDispl$Line == h),]
  msd_cellLine <- data.frame()
  for (i in c(unique(sqDispl_cellLine$Cell))){
    subset = sqDispl_cellLine[which(sqDispl_cellLine$Cell == i),]
    msd_cellLine[i,1] <- h # Cell line
    msd_cellLine[i,2] <- i # cell number
    msd_cellLine[i,3] = mean(subset$sqDispl) # means squared displacement accross all timepoints for this cell
    msd_cellLine[i,4] = sd(subset$sqDispl) # std of squared displacement
    msd_cellLine[i,5] = length(subset$sqDispl) # n: number of frames the cell is moving
  } 
  msd <- rbind(msd,msd_cellLine)
}
colnames(msd) <- c("Line","cell","msd_mean","msd_std","msd_length")
msd_correct <- msd[rowSums(is.na(msd)) != ncol(msd), ]

```

# Mean velocity on only the moving cells

Start from the data frame where we have filtered for Rel y um > 50 um (see above).
We will calculate the velocity of the cells at each time jump (every 4 min, dt = 4 min) and will take the mean velocity per cell over all the timepoints.
-> mean((Yrel_i+1 - Yrel_i)/4 min)

```{r}
# Loops: h inteates over the cell lines, i over the cells per cell line, j over the moving frames per cell lines 
# We again calculate the delta coordinate: y(i+1) - y(i) 
# We then calculate the velocity by dividing by dt = (Frame(i+1) - Frame(i))*4 = 4min (mostly)
# Take care that the velocity can be negtive (with the Squared displacement we take the kwadraat, so this is always positive)
# ->  we have to take the absolute of the movement or of the velocity (same as taking the squareroot of the square)

velocity <- data.frame()
for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
  subset_cellLine = data[which(data$Line == h),]
   for (i in c(unique(subset_cellLine$Cell))){
    subset = subset_cellLine[which(subset_cellLine$Cell == i),]
    for (j  in c(1:(nrow(subset)-1))){
      subset$deltaCoord[j] <- abs(subset[j+1,"Relative.Y.um"] - subset[j,"Relative.Y.um"]) # absolute displ., so that the vel is positive  
      subset$dTimeMin <- (subset[j+1,"Frame"] - subset[j,"Frame"])*4
      subset$vel[j] <- subset$deltaCoord[j]/subset$dTimeMin[j]
     }
     velocity <- rbind(velocity,subset)
  }
}


# Calculate the mean velocity for all cells (so this is the mean velocity over all time points per cell per line)
# The cells that are not moving are NA rows here -> remove those
vel <- data.frame()
for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
  velocity_cellLine = velocity[which(velocity$Line == h),]
  vel_cellLine <- data.frame()
  for (i in c(unique(velocity_cellLine$Cell))){
    subset = velocity_cellLine[which(velocity_cellLine$Cell == i),]
    vel_cellLine[i,1] <- h # cell line
    vel_cellLine[i,2] <- i # cell number
    vel_cellLine[i,3] = mean(subset$vel) # mean velocity all timepoints for this cell
    vel_cellLine[i,4] = sd(subset$vel) # std of vel
    vel_cellLine[i,5] = length(subset$vel) # n: number of frames the cell is moving
  } 
  vel <- rbind(vel,vel_cellLine)
}
colnames(vel) <- c("Line","cell","vel_mean","vel_std","vel_length")
vel_correct <- vel[rowSums(is.na(vel)) != ncol(vel), ]

```


# Maximum distance travelled on only the moving cells

```{r}
# Calculate the maximal distance travelled per cell (so not the final distance, but the max distance, so if they go back at the end, then this is not the distance at frame 360)
  # Iterate over the line, the cells within the line and take then the max relative distance travelled
  # take care that in the iteration over the cells (i.e. i), you iterate over all AVAILABLE cell bnumbers instead of going from 1:max(cellNumber)
# The cells that are not moving are NA rows here (so we iterate over all cell numbers, also the ones that were previously removed because dthey fo not move more than 50um) -> remove those

MaxDistance <- data.frame()
for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
  subset_cellLine = data[which(data$Line == h),]
  temp <- data.frame()
  for (i in c(unique(subset_cellLine$Cell))){
    subset = subset_cellLine[which(subset_cellLine$Cell == i),]
    temp[i,1] = as.data.frame(max(subset$Relative.Y.um))
    temp[i,2] = h # cell line
    temp[i,3] = i # cell number
   }
  MaxDistance <- rbind(MaxDistance,temp)
}
colnames(MaxDistance) <- c("MaxDistance","Line","cell")
MaxDistance <- MaxDistance[rowSums(is.na(MaxDistance)) != ncol(MaxDistance), ]

```

```{r}
# Plot the maximum travelled distance per line per cell

  # Boxplot in same order as MSD and velocity -> FINALFINAL
MaxDistance$Line <- factor(MaxDistance$Line,
    levels = c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

pdf("/media/data/lcb/lminn/Migration/Boxplot_MaxDistance-moving-avCell_boxplot_orderedCorrect-ULTIMATE.pdf")
ggplot(MaxDistance,aes(Line,MaxDistance, fill=Line)) +
    geom_boxplot() +
    geom_jitter(dotsize = .5, binaxis = "y", stackdir = "center",position = position_jitter(height = .2, width = .1)) + labs(x= "Cell line", y ="Relative displacement (um)") + 
    scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
    theme_classic()
dev.off()


```



# MSD on only the moving cells with different lag times

Previously, we have calculated the MSD with a lag time of 1, i.e. Y(t+1)-Y(t) as distance measure.
However, you can calculate the MSD with different lag times: theta = n x dt -> Evelien used n = 1:12, I choose 1:15 (max lagtime = 60min then) so we will loop over these lag times to calculate the differences and store it all in a list with matrices of each lag time.
In our case dt = 4, but this we take into account afterwards to plot the MSD at different lag times (see paper Evelien), represented as boxplot of all the cells, 1 color per cell line

```{r}
# Calculate the square displacement (kwadraat of the delta displacement at each time interval; for all the cells)
  # Here we take time interval dt = 1 ; so every row contains the squared distance travelled between t+1 and t
  # Iterate over the line, the cells within the line and then all t+1 - t displacements 
  # At the iteration with "j" : So what you do is that you fill at the firt iteration every where the number of y2-y1 and then with each iteration you overwrite the jth line, this makes that the 360th line is not empty but contains the firts values (which is almost always 0)
  # take care that in the iteration over the cells (i.e. i), you iterate over all AVAILABLE cell bnumbers instead of going from 1:max(cellNumber)
  # Similar, do not iterate over the nFrames as they are now cut, iterate over the nRows remaining
  # n interates over the lag times; h over the cell lines, i over the cells, j over the frames

sqDispl_list <- list()
for (n in c(1:40)){
    sqDispl <- data.frame()
    for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
      subset_cellLine = data[which(data$Line == h),]
      for (i in c(unique(subset_cellLine$Cell))){
        subset = subset_cellLine[which(subset_cellLine$Cell == i),]
        for (j  in c(1:(nrow(subset)-1))){
          subset$deltaCoord[j] <- subset[j+n,"Relative.Y.um"] - subset[j,"Relative.Y.um"]   
          subset$sqDispl[j] <- subset$deltaCoord[j]*subset$deltaCoord[j]
         }
        sqDispl <- rbind(sqDispl,subset)
      }
    }
    sqDispl_list[[n]] <- sqDispl
}

# Calculate the average, std and n (number of dt's, is number of frames in dt =1) of the MSD for all cells (so this is the average MSD over all time points per cell per line)
# The cells that are not moving are NA rows here -> remove those
# Also remove NAs when calculating the mean; these NAs are there for lag times > 1 because it runs out of frames to calculate the next sqDislp

MSD_list <- list()
for (n in c(1:40)){
  sqDispl <- sqDispl_list[[n]]
  msd <- data.frame()
  for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
    sqDispl_cellLine = sqDispl[which(sqDispl$Line == h),]
    msd_cellLine <- data.frame()
    for (i in c(unique(sqDispl_cellLine$Cell))){
      subset = sqDispl_cellLine[which(sqDispl_cellLine$Cell == i),]
      msd_cellLine[i,1] <- h # Cell line
      msd_cellLine[i,2] <- i # cell number
      msd_cellLine[i,3] = mean(subset$sqDispl,na.rm=TRUE) # means squared displacement accross all timepoints for this cell
      msd_cellLine[i,4] = sd(subset$sqDispl,na.rm=TRUE) # std of squared displacement
      msd_cellLine[i,5] = length(subset$sqDispl) # n: number of frames the cell is moving
    } 
    msd <- rbind(msd,msd_cellLine)
  }
  colnames(msd) <- c("Line","cell","msd_mean","msd_std","msd_length")
  msd_correct <- msd[rowSums(is.na(msd)) != ncol(msd), ]
  MSD_list[[n]] <- msd_correct
}

```


```{r}
# Plot the mean MSD per lag time with a boxplot (over all the cells), for each cell line
  # Make a data frame with all the lag times from the list together
total_MSD <- data.frame()
for (n in c(1:40)){
  temp <- MSD_list[[n]]
  temp$LagTime <- n
  total_MSD <- rbind(total_MSD,temp)
}

# Add the real lag time, so in min (not just n)
total_MSD$LagTimeMin <- total_MSD$LagTime*4

# Plot all the lagtimes in one plot
  # in alphabetic order
total_MSD$Line <- factor(total_MSD$Line,
    levels = c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

```

```{r}
# Plot of the mean MSD per cell per line for lag time 5
  # correct order
  # -> FINALFINAL

total_MSD$Line <- factor(total_MSD$Line,
    levels = c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

# pdf("/media/data/lcb/lminn/Migration/Boxplot_MSDLagTimeAll-moving-avCell_boxplot_orderedCorrect-ULTIMATE.pdf")
#  total_MSD_lagSubset <- total_MSD[which(total_MSD$LagTime == 5),]
# print(ggplot(total_MSD_lagSubset,aes(Line,msd_mean, fill=Line)) +
#     geom_boxplot() +
#     geom_jitter(dotsize = .5, binaxis = "y", stackdir = "center",position = position_jitter(height = .2, width = .1)) + 
#     labs(x= "Cell line", y ="MSD (um2)") + 
#     scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
#     theme_classic() +
#     ggtitle("MSD of lag time 5"))
# dev.off()


```


# Mean velocity on only the moving cells with different lag times

```{r}
# Loops: h inteates over the cell lines, i over the cells per cell line, j over the moving frames per cell lines 
# n interates over the lag times; h over the cell lines, i over the cells, j over the frames
# We again calculate the delta coordinate: y(i+1) - y(i) 
# We then calculate the velocity by dividing by dt = (Frame(i+1) - Frame(i))*4 = 4min (mostly)
# Take care that the velocity can be negtive (with the Squared displacement we take the kwadraat, so this is always positive)
# ->  we have to take the absolute of the movement or of the velocity (same as taking the squareroot of the square)
# n interates over the lag times; h over the cell lines, i over the cells, j over the frames

vel_list <- list()
for (n in c(1:15)){
  velocity <- data.frame()
  for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
    subset_cellLine = data[which(data$Line == h),]
    for (i in c(unique(subset_cellLine$Cell))){
      subset = subset_cellLine[which(subset_cellLine$Cell == i),]
      for (j  in c(1:(nrow(subset)-1))){
        subset$deltaCoord[j] <- abs(subset[j+n,"Relative.Y.um"] - subset[j,"Relative.Y.um"]) # absolute dY, so that the vel is positive  
        subset$dTimeMin[j] <- (subset[j+n,"Frame"] - subset[j,"Frame"])*4
        subset$vel[j] <- subset$deltaCoord[j]/subset$dTimeMin[j]
      }
      velocity <- rbind(velocity,subset)
    }
  }
  vel_list[[n]] <- velocity
}

# with the paremeters renamed (but does not work.., this is just an example to understand the i,j,...)
      # vel_list <- list()
      # for (lag in c(1:15)){
      #   velocity <- data.frame()
      #   for (line in c('MM001','MM011','MM029','MM031','MM047','MM057','MM074','MM087','MM099')){
      #     subset_cellLine = data[which(data$Line == line),]
      #     for (cell in c(unique(subset_cellLine$Cell))){
      #       subset = subset_cellLine[which(subset_cellLine$Cell == cell),]
      #       for (frame  in c(1:(nrow(subset)-1))){
      #         subset$deltaCoord[frame] <- abs(subset[frame+lag,"Relative.Y.um"] - subset[frame,"Relative.Y.um"]) # absolute dY, so that the velocity is positive  
      #         subset$dTimeMin[frame] <- (subset[frame+lag,"Frame"] - subset[frame,"Frame"])*4
      #         subset$vel[frame] <- subset$deltaCoord[frame]/subset$dTimeMin[frame]
      #       }
      #       velocity <- rbind(velocity,subset)
      #     }
      #   }
      #   vel_list[[lag]] <- velocity
      # }

# Calculate the mean velocity for all cells (so this is the mean velocity over all time points per cell per line)
# The cells that are not moving are NA rows here -> remove those

VEL_list <- list()
for (n in c(1:15)){
  velocity <- vel_list[[n]]
  vel <- data.frame()
  for (h in c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099')){
    velocity_cellLine = velocity[which(velocity$Line == h),]
    vel_cellLine <- data.frame()
    for (i in c(unique(velocity_cellLine$Cell))){
      subset = velocity_cellLine[which(velocity_cellLine$Cell == i),]
      vel_cellLine[i,1] <- h # cell line
      vel_cellLine[i,2] <- i # cell number
      vel_cellLine[i,3] = mean(subset$vel,na.rm=TRUE) # mean velocity all timepoints for this cell
      vel_cellLine[i,4] = sd(subset$vel,na.rm=TRUE) # std of vel
      vel_cellLine[i,5] = length(subset$vel) # n: number of frames the cell is moving
    } 
    vel <- rbind(vel,vel_cellLine)
  }
  colnames(vel) <- c("Line","cell","vel_mean","vel_std","vel_length")
  vel_correct <- vel[rowSums(is.na(vel)) != ncol(vel), ]
  VEL_list[[n]] <- vel_correct
}
```


```{r}
# Plot the mean Velocity per lag time with a boxplot (over all the cells), for each cell line
  # Make a data frame with all the lag times from the list together
total_VEL <- data.frame()
for (n in c(1:15)){
  temp <- VEL_list[[n]]
  temp$LagTime <- n
  total_VEL <- rbind(total_VEL,temp)
}

# Add the real lag time, so in min (not just n)
total_VEL$LagTimeMin <- total_VEL$LagTime*4

# Plot

 # in the increasing order
total_VEL$Line <- factor(total_VEL$Line,
    levels = c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

pdf("/media/data/lcb/lminn/Migration/Boxplot_Velocity-LagTimes-moving-avCell_boxplot_ordered.pdf")
ggplot(total_VEL,aes(x=LagTimeMin,y=vel_mean, fill = Line,group = interaction(Line, LagTimeMin))) +
    geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
  scale_y_continuous(limits = c(0, 1.8))+
  labs(x= "Time lag (min)", y ="Velocity (um/min)") +
    theme_classic()
dev.off()

# Plot only the odd lags for more visibility

total_VEL_odd <- total_VEL[which(total_VEL$LagTime %in% c(1,3,5,7,9,11,13,15)),]

 # in the increasing order
total_VEL_odd$Line <- factor(total_VEL_odd$Line,
    levels =c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

pdf("/media/data/lcb/lminn/Migration/Boxplot_Velocity-LagTimes-moving-avCell_boxplot_ordered_oddLags.pdf")
ggplot(total_VEL_odd,aes(x=LagTimeMin,y=vel_mean, fill = Line,group = interaction(Line, LagTimeMin))) +
  geom_boxplot(outlier.shape = NA,width = 5,position=position_dodge(7)) +
  labs(x= "Time lag (min)", y ="Velocity (um/min)") +
  scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
  scale_y_continuous(limits = c(0, 1.8))+
  theme_classic()
dev.off()


```


```{r}
# Plot the mean Velocity per cell per line for different lag times
  # in the increasing order

total_VEL$Line <- factor(total_VEL$Line,
    levels = c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

pdf("/media/data/lcb/lminn/Migration/Boxplot_VelocityLagTimeAll-moving-avCell_boxplot_ordered.pdf")
for (n in c(1:15)){
 total_VEL_lagSubset <- total_VEL[which(total_VEL$LagTime == n),]
print(ggplot(total_VEL_lagSubset,aes(Line,vel_mean, fill=Line)) +
    geom_boxplot() +
    geom_jitter(dotsize = .5, binaxis = "y", stackdir = "center") + 
    labs(x= "Cell line", y ="Velocity (um/min)") + 
    scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
    theme_classic() +
    ggtitle(paste("Velocity of lag time",n,sep=" ")))
}
dev.off()

# Plot the mean Velocity per cell per line for lagtime 1
  # correct order
# -> FINAL

total_VEL$Line <- factor(total_VEL$Line,
    levels = c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

pdf("/media/data/lcb/lminn/Migration/Boxplot_VelocityLagTimeAll-moving-avCellorderedCorrect-ULTIMATE.pdf")

 total_VEL_lagSubset <- total_VEL[which(total_VEL$LagTime == 1),]
print(ggplot(total_VEL_lagSubset,aes(Line,vel_mean, fill=Line)) +
    geom_boxplot() +
    geom_jitter(dotsize = .5, binaxis = "y", stackdir = "center",position = position_jitter(height = .2, width = .1)) + 
    labs(x= "Cell line", y ="Velocity (um/min)") + 
    scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
    theme_classic() +
    ggtitle("Velocity of lag time 1"))
dev.off()

# Plot of the mean MSD per cell per line for lag time 5
  # correct order
  # -> FINAL

total_MSD$Line <- factor(total_MSD$Line,
    levels = c('MM001','MM011','MM031','MM074','MM087','MM057','MM029','MM047','MM099'),ordered = TRUE)

pdf("/media/data/lcb/lminn/Migration/Boxplot_MSDLagTimeAll-moving-avCell_boxplot_orderedCorrect-ULTIMATE.pdf")
 total_MSD_lagSubset <- total_MSD[which(total_MSD$LagTime == 5),]
print(ggplot(total_MSD_lagSubset,aes(Line,msd_mean, fill=Line)) +
    geom_boxplot() +
    geom_jitter(dotsize = .5, binaxis = "y", stackdir = "center",position = position_jitter(height = .2, width = .1)) + 
    labs(x= "Cell line", y ="MSD (um2)") + 
    scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
    theme_classic() +
    ggtitle("MSD of lag time 5"))
dev.off()


```


## UMAP without persistence but with MM074

```{r}
# Make a cells - measurements matrix
  # lagtimes 5 for the MSD and velocity
BigMatrix <- data.frame()
BigMatrix <- cbind(MSD_list[[5]]$msd_mean,VEL_list[[5]]$vel_mean)
BigMatrix <- cbind(BigMatrix,MaxDistance["MaxDistance"])
colnames(BigMatrix) <- c('MSD','Velocity','MaxDistance')
names <- paste(MSD_list[[5]]$Line, MSD_list[[5]]$cell,sep="_")
rownames(BigMatrix) <- names

# Delete rows with an NA
row.has.na <- apply(BigMatrix, 1, function(x){any(is.na(x))})
BigMatrix_filtered <- BigMatrix[!row.has.na,] # Filetered 5 cells , 365 remaining

# Heatmap on z-scored data
BigMatrix_filtered_norm <- scale(BigMatrix_filtered, center = TRUE, scale = TRUE)
save(BigMatrix_filtered_norm,file="/media/data/lcb/lminn/Migration/Matrix_NoPersistency_normalised.RData")

# UMAP - on filtered, scaled and normalised data
  # -> FINAL
library(umap)

      # needs cells vs genes matrix 
set.seed(111)
umap = umap(BigMatrix_filtered_norm)

  # color by cell line
pdf("/media/data/lcb/lminn/Migration/UMAP_noPersistency_Color-cellLineCorrect-ULTIMATE.pdf")
rownames(umap$layout) <- rownames(BigMatrix_filtered_norm)
colnames(umap$layout) <- c("UMAP_1", "UMAP_2")
names<- sapply(strsplit(rownames(BigMatrix_filtered_norm),split="_"),"[",1)
UMAP <- cbind(umap$layout, names)
UMAP[,"names"]= as.factor(UMAP[,"names"]) # Factorisation makes the order numerical
color_easy = c("#FB9999","#1F78B4", "#6A3D9A","#FF7F00","#99CBE0" ,"#E31A1A","#32A02C", "#FDBF6F","#CE7EBD")[factor(UMAP[,"names"])]
plot(UMAP[,1],UMAP[,2],type="p", pch=20, col=color_easy)
dev.off()


  # Color by inv/prol/switch
pdf("/media/data/lcb/lminn/Migration/UMAP_noPersistency_Color-TypeCorrect-ULTIMATE.pdf")
rownames(umap$layout) <- rownames(BigMatrix_filtered_norm)
colnames(umap$layout) <- c("UMAP_1", "UMAP_2")
UMAP <- cbind(umap$layout, names)
UMAP[,"names"][which(UMAP[,"names"]=="MM001")] <- "Prol"
UMAP[,"names"][which(UMAP[,"names"]=="MM011")] <- "Prol"
UMAP[,"names"][which(UMAP[,"names"]=="MM031")] <- "Prol"
UMAP[,"names"][which(UMAP[,"names"]=="MM029")] <- "Inv"
UMAP[,"names"][which(UMAP[,"names"]=="MM047")] <- "Inv"
UMAP[,"names"][which(UMAP[,"names"]=="MM099")] <- "Inv"
UMAP[,"names"][which(UMAP[,"names"]=="MM057")] <- "Switch"
UMAP[,"names"][which(UMAP[,"names"]=="MM074")] <- "Switch"
UMAP[,"names"][which(UMAP[,"names"]=="MM087")] <- "Switch"
UMAP[,"names"] = as.factor(UMAP[,"names"]) # factor 1 = inv, 2 = prol, 3 = switch
color_easy = c("#ff5b35ff","#0066ffff","#800080ff")[factor(UMAP[,"names"])]
plot(UMAP[,1],UMAP[,2],type="p", pch=20, col=color_easy)
dev.off()

# Color by inv/prol/switch - with legend
pdf("/media/data/lcb/lminn/Migration/UMAP_noPersistency_Color-TypeCorrect-withLegend-FINAL.pdf")
rownames(umap$layout) <- rownames(BigMatrix_filtered_norm)
colnames(umap$layout) <- c("UMAP_1", "UMAP_2")
UMAP <- cbind(umap$layout, names)
UMAP[,"names"][which(UMAP[,"names"]=="MM001")] <- "Prol"
UMAP[,"names"][which(UMAP[,"names"]=="MM011")] <- "Prol"
UMAP[,"names"][which(UMAP[,"names"]=="MM031")] <- "Prol"
UMAP[,"names"][which(UMAP[,"names"]=="MM029")] <- "Inv"
UMAP[,"names"][which(UMAP[,"names"]=="MM047")] <- "Inv"
UMAP[,"names"][which(UMAP[,"names"]=="MM099")] <- "Inv"
UMAP[,"names"][which(UMAP[,"names"]=="MM057")] <- "Switch"
UMAP[,"names"][which(UMAP[,"names"]=="MM074")] <- "Switch"
UMAP[,"names"][which(UMAP[,"names"]=="MM087")] <- "Switch"
UMAP[,"names"] = as.factor(UMAP[,"names"]) # factor 1 = inv, 2 = prol, 3 = switch
color_easy = c("#ff5b35ff","#0066ffff","#800080ff")[factor(UMAP[,"names"])]
plot(UMAP[,1],UMAP[,2],type="p", pch=20, col=color_easy)
legend("bottomleft", inset=.02, title="Type",
   c("Mesenchymal-like","Melanocyte-like","Intermediate"), fill=c("#ff5b35ff","#0066ffff","#800080ff"), horiz=TRUE, cex=0.5)
dev.off()

  # color by velocity 
pdf("/media/data/lcb/lminn/Migration/UMAP_noPersistency_Color-Velocity-ULTIMATE.pdf")
rownames(umap$layout) <- rownames(BigMatrix_filtered_norm)
colnames(umap$layout) <- c("UMAP_1", "UMAP_2")
set.seed(111)
UMAP <- as.data.frame(cbind(umap$layout, BigMatrix_filtered_norm[,"Velocity"]))
colnames(UMAP) <- c("UMAP_1", "UMAP_2","Velocity")
colorPal <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
UMAP$col <- colorPal(20)[as.numeric(cut(UMAP$Velocity,breaks = 20))]
plot(UMAP[,1],UMAP[,2],type="p", pch=20, col=UMAP$col)
dev.off()

  # color by velocity  - new color gradient
pdf("/media/data/lcb/lminn/Migration/UMAP_noPersistency_Color-Velocity-ULTIMATE.pdf")
rownames(umap$layout) <- rownames(BigMatrix_filtered_norm)
colnames(umap$layout) <- c("UMAP_1", "UMAP_2")
set.seed(111)
UMAP <- as.data.frame(cbind(umap$layout, BigMatrix_filtered_norm[,"Velocity"]))
colnames(UMAP) <- c("UMAP_1", "UMAP_2","Velocity")
library(ggplot2)
ggplot(UMAP, aes(x=UMAP_1, y=UMAP_2,color=Velocity)) + geom_point() +
  theme_classic() +
  scale_color_gradientn(colors=colorPal(15), limits = c(-2, 3.3), oob=scales::squish)
dev.off() 



UMAP_sorted <- UMAP[order(UMAP$Velocity),]

pdf("/media/data/lcb/lminn/Migration/UMAP_noPersistency_Color-Velocity-Legend-ULTIMATE.pdf", width=8, height=8)
layout(matrix(1:2,ncol=2), width = c(2,2),height = c(1,1))
colorPal <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
legend_image <- as.raster(matrix(rev(colorPal(20)), ncol=1))
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '')
labels.name <- seq(from = -1.603976, to = 2.708782, length.out = 8labels.name <- round(labels.name, 1)
text(x=1.5, y = seq(0,1,l=8), cex=1, labels = labels.name)
rasterImage(legend_image, 0, 0, 1, 1)
dev.off()

```


# Statistical significance in boxplots

```{r}

# load the AUC matrix
load("BL_regulons_and_signatures.RData") 
to_test<-BL_regulons_and_signatures[c("FOSL1 (1378g)","IRF2 (208g)","STAT1 (676g)","EGR3 (103g)"),]
to_test<-melt(to_test)
load("meta_data.RData")
to_test_meta<-merge(to_test, meta_data, by.x="Var2",by.y="row.names")
to_test_meta<-subset(to_test_meta, select=c("Var2","Var1","value","Cell_Line"))
to_test_meta$PHENOTYPE<-ifelse(to_test_meta$Cell_Line %in% c("A375","MM029","MM047","MM099"), "INV", "PRO")
to_test_HOEK_INV<-subset(to_test_meta, Var1=="HOEK_INV")
 wilcox.test(to_test_HOEK_INV$value~to_test_HOEK_INV$PHENOTYPE)
 
### for: Boxplot_MaxDistance-moving-avCell_boxplot_orderedCorrect-ULTIMATE
  # prol (MEL+INT) vs inv
temp <- MaxDistance
temp$Phenotye <- ifelse(temp$Line %in% c("MM029","MM047","MM099"), "INV", "PRO")
wilcox.test(temp$MaxDistance~temp$Phenotye)

  # MEL vs INT (with MM074)
subset <- temp[which(temp$Line %in% c("MM001","MM011","MM031","MM074","MM087","MM057")),]
subset$Phenotye <- ifelse(subset$Line %in% c("MM001","MM011","MM031"), "MEL", "INT")
wilcox.test(subset$MaxDistance~subset$Phenotye)

  # MEL vs INT (without MM074)
subset <- temp[which(temp$Line %in% c("MM001","MM011","MM031","MM087","MM057")),]
subset$Phenotye <- ifelse(subset$Line %in% c("MM001","MM011","MM031"), "MEL", "INT")
wilcox.test(subset$MaxDistance~subset$Phenotye)

### for: Boxplot_MSDLagTimeAll-moving-avCell_boxplot_orderedCorrect-ULTIMATE
  # prol (MEL+INT) vs inv
temp <- total_MSD_lagSubset
temp$Phenotye <- ifelse(temp$Line %in% c("MM029","MM047","MM099"), "INV", "PRO")
wilcox.test(temp$msd_mean~temp$Phenotye)

  # MEL vs INT (with MM074)
subset <- temp[which(temp$Line %in% c("MM001","MM011","MM031","MM074","MM087","MM057")),]
subset$Phenotye <- ifelse(subset$Line %in% c("MM001","MM011","MM031"), "MEL", "INT")
wilcox.test(subset$msd_mean~subset$Phenotye)

  # MEL vs INT (without MM074)
subset <- temp[which(temp$Line %in% c("MM001","MM011","MM031","MM087","MM057")),]
subset$Phenotye <- ifelse(subset$Line %in% c("MM001","MM011","MM031"), "MEL", "INT")
wilcox.test(subset$msd_mean~subset$Phenotye)

### for: Boxplot_VelocityLagTimeAll-moving-avCellorderedCorrect-ULTIMATE
  # prol (MEL+INT) vs inv
temp <- total_VEL_lagSubset
temp$Phenotye <- ifelse(temp$Line %in% c("MM029","MM047","MM099"), "INV", "PRO")
wilcox.test(temp$vel_mean~temp$Phenotye)

  # MEL vs INT (with MM074)
subset <- temp[which(temp$Line %in% c("MM001","MM011","MM031","MM074","MM087","MM057")),]
subset$Phenotye <- ifelse(subset$Line %in% c("MM001","MM011","MM031"), "MEL", "INT")
wilcox.test(subset$vel_mean~subset$Phenotye)

  # MEL vs INT (without MM074)
subset <- temp[which(temp$Line %in% c("MM001","MM011","MM031","MM087","MM057")),]
subset$Phenotye <- ifelse(subset$Line %in% c("MM001","MM011","MM031"), "MEL", "INT")
wilcox.test(subset$vel_mean~subset$Phenotye)


 total_VEL_lagSubset <- total_VEL[which(total_VEL$LagTime == 1),]
print(ggplot(total_VEL_lagSubset,aes(Line,vel_mean, fill=Line)) +
    geom_boxplot() +
    geom_jitter(dotsize = .5, binaxis = "y", stackdir = "center",position = position_jitter(height = .2, width = .1)) + 
    labs(x= "Cell line", y ="Velocity (um/min)") + 
    scale_fill_manual(values=c("#FB9999","#1F78B4", "#FF7F00","#32A02C","#FDBF6F" ,"#E31A1A","#6A3D9A", "#99CBE0","#CE7EBD")) +
    theme_classic() +
    ggtitle("Velocity of lag time 1"))
dev.off()


```

